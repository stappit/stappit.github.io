<!DOCTYPE html>

<html lang="en">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="stylesheet" href="../../css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="../../css/default.css">
	<link rel="alternate" type="application/atom+xml" title="Brian's feed" href="atom.xml" />

        <title>My Hakyll Blog - Okasaki's PFDS, Chapter 3</title>
    </head>

    <body>
    <nav id="navbar-container" class="navbar navbar-default navbar-static-top">
	    <div class="container">
		    <div class="navbar-header">
			    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				    <span class="sr-only">Toggle navigation</span>
				    <span class="icon-bar"></span>
				    <span class="icon-bar"></span>
				    <span class="icon-bar"></span>
			    </button>
			    <a class="navbar-brand" href="../../index.html">Brian</a>
		    </div>
		    <div id="navbar" class="navbar-collapse collapse">
			    <ul class="nav navbar-nav">
				    <li><a class="blog-nav-item" href="../../index.html"><i class="fa fa-home"></i> Recent</a></li>
				    <li><a class="blog-nav-item" href="../../archive.html"><i class="fa fa-globe"></i> Archive</a></li>
				    <li><a class="blog-nav-item" href="https://github.com/stappit"><i class="fa fa-github"></i> GitHub</a></li>
				    <li><a class="blog-nav-item" href="../../about.html"><i class="fa fa-info-circle"></i> About</a></li>
				    <li><a class="blog-nav-item" href="../../atom.xml"><i class="fa fa-rss"></i> Atom</a></li>
			    </ul>
		    </div><!--/.nav-collapse -->
	    </div>
    </nav>

    <div id="content" class="container">
	    


<h1 class="blog-post-title">Okasaki's PFDS, Chapter 3</h1>
<p class="blog-post-meta">
Posted on November  1, 2015  by Brian </br>
 Tags: <a href="../../tags/fp.html">fp</a>, <a href="../../tags/haskell.html">haskell</a>, <a href="../../tags/okasaki.html">okasaki</a>, <a href="../../tags/leftist%20tree.html">leftist tree</a>, <a href="../../tags/leftist%20heap.html">leftist heap</a>, <a href="../../tags/binomial%20tree.html">binomial tree</a>, <a href="../../tags/binomial%20heap.html">binomial heap</a>, <a href="../../tags/heap.html">heap</a>, <a href="../../tags/red%20black%20tree.html">red black tree</a> </br>
 Category: <a href="../../categories/pfds.html">pfds</a> 
</p>

<p>This post contains my solutions to the exercises in chapter 3 of Okasaki’s ‘Purely Functional Data Structures’. The latest source code can be found in <a href="https://github.com/stappit/okasaki-pfds">my GitHub repo</a>.</p>
<h2 id="leftist-trees">Leftist Trees</h2>
<p>The right spine of a binary tree is the rightmost path from that node to an empty node. For example, the empty tree has a right spine of length 0.</p>
<p>A binary tree is said to satisfy the leftist property if every node has the property that the rank of its left child (= length of its right spine) is greater than or equal to the rank of its right child. A leftist tree is a binary tree with the leftist property.</p>
<p>The following are some examples of (the shape of) leftist trees where the keys have been omitted. The number at each node instead indicates the length of its right spine and any blank nodes are empty nodes.</p>
<figure>
<img src="../../images/leftist-tree-1-node.pdf.png" alt="The only leftist tree with 1 node." /><figcaption>The only leftist tree with 1 node.</figcaption>
</figure>
<figure>
<img src="../../images/leftist-tree-2-nodes.pdf.png" alt="The only leftist tree with 2 nodes." /><figcaption>The only leftist tree with 2 nodes.</figcaption>
</figure>
<figure>
<img src="../../images/leftist-tree-3-nodes-1.pdf.png" alt="A leftist tree with 3 nodes." /><figcaption>A leftist tree with 3 nodes.</figcaption>
</figure>
<figure>
<img src="../../images/leftist-tree-3-nodes-2.pdf.png" alt="A leftist tree with 3 nodes." /><figcaption>A leftist tree with 3 nodes.</figcaption>
</figure>
<h2 id="heaps">Heaps</h2>
<p>A tree is said to be heap-ordered if the key of any node is less than or equal to the key of any of its descendants. We capture this structure in the <code>Heap</code> typeclass.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Heap</span> h <span class="kw">where</span>
<span class="ot">  empty     ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> h a
<span class="ot">  isEmpty   ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> h a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">  insert    ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span>   a <span class="ot">-&gt;</span> h a <span class="ot">-&gt;</span> h a
<span class="ot">  merge     ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> h a <span class="ot">-&gt;</span> h a <span class="ot">-&gt;</span> h a
<span class="ot">  findMin   ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> h a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a     <span class="co">-- may be empty</span>
<span class="ot">  deleteMin ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> h a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (h a) <span class="co">-- may be empty</span></code></pre></div>
<p>A leftist heap is a heap-ordered leftist tree. We can implement this as a binary tree with a heap instance.</p>
<h2 id="exercise-3.1">Exercise 3.1</h2>
<p>Prove that the right spine of a leftist heap of size <span class="math inline">\(n\)</span> contains at most <span class="math inline">\(\left\lfloor \log (n+1) \right\rfloor\)</span> elements.</p>
<h2 id="solution-3.1">Solution 3.1</h2>
<p>We prove the stronger result that a leftist tree of rank <span class="math inline">\(r\)</span> is complete up to depth <span class="math inline">\(r-1\)</span>. The solution then follows from the fact that a tree complete up to depth <span class="math inline">\(r-1\)</span> has at least <span class="math inline">\(2^r - 1\)</span> nodes.</p>
<p>The proof proceeds by induction on the number of nodes.</p>
<p>The statement is true for the empty tree.</p>
<p>Let <span class="math inline">\(T\)</span> be a leftist tree of rank <span class="math inline">\(r\)</span> with <span class="math inline">\(n\)</span> nodes. Then each child is a leftist tree with fewer nodes, so we may apply the induction hypothesis to each child. The right child has rank <span class="math inline">\(r-1\)</span> and, by the leftist property of <span class="math inline">\(T\)</span>, the left child has rank at least <span class="math inline">\(r-1\)</span>. By the induction hypothesis, each child is complete up to depth <span class="math inline">\(r-2\)</span>. Therefore, <span class="math inline">\(T\)</span> is complete up to depth <span class="math inline">\(r-1\)</span>. □</p>
<h2 id="exercise-3.2">Exercise 3.2</h2>
<p>Define <code>insert</code> directly rather than via a call to <code>merge</code>.</p>
<h2 id="solution-3.2">Solution 3.2</h2>
<p>See <a href="https://github.com/stappit/okasaki-pfds/blob/2ecdad0e72de18d8b250e6cddad011b00debecda/src/Chap03/Exercise02.hs">source</a>.</p>
<h2 id="exercise-3.3">Exercise 3.3</h2>
<p>Implement a function <code>fromList</code> of type</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromList ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">LeftistHeap</span> a</code></pre></div>
<p>that produces a leftist heap from an unordered list of elements in <span class="math inline">\(\mathcal O (n)\)</span> time by merging in pairs.</p>
<h2 id="solution-3.3">Solution 3.3</h2>
<p>See <a href="https://github.com/stappit/okasaki-pfds/blob/ca52a0986bb5baab4bb36266d39235f035378f80/src/Chap03/Exercise03.hs">source</a>.</p>
<p>Note that we only use the Heap API, so we are guaranteed both the heap invariants and the leftist invariants. We must only check that the implementation is in fact linear.</p>
<p>Let’s look at the first few cases in detail.</p>
<ul>
<li><p>The first call to <code>mergePairs</code> calls <code>merge</code> a total of <span class="math inline">\(n/2\)</span> times on two heaps of size <span class="math inline">\(2^0\)</span>. This has a cost of <span class="math inline">\(\frac{n}{2} \log 2 = \frac{n}{2}\)</span>.</p></li>
<li><p>The second call to <code>mergePairs</code> calls <code>merge</code> a total of <span class="math inline">\(n/4\)</span> times on heaps of size <span class="math inline">\(2^1\)</span>. This has a cost of <span class="math inline">\(\frac{n}{4} \log 4 = \frac{n}{4} \cdot 2\)</span>.</p></li>
<li><p>The third call to <code>mergePairs</code> calls <code>merge</code> a total of <span class="math inline">\(n/8\)</span> times on heaps of size <span class="math inline">\(2^2\)</span>. This has a cost of <span class="math inline">\(\frac{n}{8} \log 8 = \frac{n}{8} \cdot 3\)</span>.</p></li>
</ul>
<p>Indeed, the <span class="math inline">\(k\)</span>th all to <code>mergePairs</code> calls <code>merge</code> a total of <span class="math inline">\(\frac{n}{2^k}\)</span> times on two heaps of size <span class="math inline">\(2^{k-1}\)</span>. From this we see that the total cost is of order</p>
<p class="mathjaxWide"><span class="math display">\[
\sum_{k=1}^{\log n} \frac{n}{2^k} k
=
n \sum_{k=1}^{\log n} \frac{k}{2^k}
.
\]</span></p>
<p>Since</p>
<p class="mathjaxWide"><span class="math display">\[
\frac{2i+1}{2^{2i+1}} + \frac{2i+2}{2^{2i+2}} \le \frac{1}{2^i}
,
\]</span></p>
<p>we can pair the terms in the sum to get a total cost of order</p>
<p class="mathjaxWide"><span class="math display">\[
n \sum_{k=0}^{\log n} \frac{1}{2^k}
\le
n \sum_{k=0}^{\infty} \frac{1}{2^k}
\le
2n
.
\]</span></p>
<p>□</p>
<h2 id="exercise-3.4">Exercise 3.4</h2>
<p>A binary tree is said to satisfy the weight-biased leftist property if the size (= number of nodes) of any node’s left child is at least as large as that of its right child.</p>
<ol type="1">
<li>Prove that the right spine of a weight-biased leftist heap contains at most <span class="math inline">\(\left\lfloor \log (n+1) \right\rfloor\)</span> elements.</li>
<li>Modify the implementation in figure 3.2 to obtain weight-biased leftist heaps.</li>
<li>Modify <code>merge</code> for weight-biased leftist heaps to operate in a single top-down pass.</li>
<li>What advantages would the top-down version of <code>merge</code> have in a lazy environment? In a concurrent environment?</li>
</ol>
<h2 id="solution-3.4">Solution 3.4</h2>
<p><strong>Item 1.</strong></p>
<p>The proof is almost identical to that for leftist trees in <a href="#exercise-3.1">Exercise 3.1</a>.</p>
<p>The statement is true for the empty tree.</p>
<p>Let <span class="math inline">\(T\)</span> be a weight-biased leftist heap of rank <span class="math inline">\(r\)</span> with <span class="math inline">\(n\)</span> nodes. Then each child is a weight-biased leftist tree with fewer nodes. The right child has rank <span class="math inline">\(r-1\)</span> and by the induction hypothesis must have at least <span class="math inline">\(2^{r-1}-1\)</span> nodes. By the weight-biased property of <span class="math inline">\(T\)</span>, the left child also has at least <span class="math inline">\(2^{r-1}-1\)</span> nodes. Therefore, <span class="math inline">\(T\)</span> has at least <span class="math inline">\(2^r-1\)</span> nodes. In other words, <span class="math inline">\(\log (n+1) \ge r\)</span>. Since <span class="math inline">\(r\)</span> is an integer, <span class="math inline">\(\left\lfloor \log (n+1) \right\rfloor \ge r\)</span>. □</p>
<p><strong>Item 2.</strong></p>
<p>The implementation of leftist heaps encompasses both the leftist and weight-biased variants.</p>
<p><strong>Item 3.</strong></p>
<p>See <a href="https://github.com/stappit/okasaki-pfds/blob/ca52a0986bb5baab4bb36266d39235f035378f80/src/Chap03/Exercise04.hs">source</a>.</p>
<p><strong>Item 4.</strong></p>
<p>In a lazy environment, the top-down version has the advantage that some queries can be made to the merged heap without calculating the entire heap. For example, <code>weight (merge h1 h2)</code> would run in constant time regardless of the sizes of <code>h1</code> and <code>h2</code>.</p>
<h2 id="binomial-heaps">Binomial Heaps</h2>
<p>We define the binomial tree of rank 0 to be the singleton node.</p>
<figure>
<img src="../../images/binomial-tree-0.pdf.png" alt="The binomial tree of rank 0" class="nottoobig" /><figcaption>The binomial tree of rank 0</figcaption>
</figure>
<p>The binomial tree of rank r is defined as the tree formed by adding the binomial tree of rank n-1 as a left child of itself.</p>
<figure>
<img src="../../images/binomial-tree-1.pdf.png" alt="The binomial tree of rank 1" class="nottoobig" /><figcaption>The binomial tree of rank 1</figcaption>
</figure>
<figure>
<img src="../../images/binomial-tree-2.pdf.png" alt="The binomial tree of rank 2" /><figcaption>The binomial tree of rank 2</figcaption>
</figure>
<figure>
<img src="../../images/binomial-tree-3.pdf.png" alt="The binomial tree of rank 3" /><figcaption>The binomial tree of rank 3</figcaption>
</figure>
<p>Note that the binomial tree of rank r has exactly <span class="math inline">\(2^r\)</span> nodes. This follows from the fact that we double the number of nodes in the tree each time we increase the rank by 1.</p>
<p>There is an alternative definition of binomial trees. A binomial tree of rank <span class="math inline">\(r\)</span> is a node with <span class="math inline">\(r\)</span> children <span class="math inline">\(t_1, \dotsc, t_r\)</span>, where <span class="math inline">\(t_i\)</span> is a binomial tree of rank <span class="math inline">\(r-i\)</span>.</p>
<p>We represent a node in a binomial tree as a key with a list of children. The extra <code>Int</code> is to keep track of the rank.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BinomialTree</span> a <span class="fu">=</span> <span class="dt">Node</span> <span class="dt">Int</span> a [<span class="dt">BinTree</span> a]
                    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</code></pre></div>
<p>We shall maintain two invariants:</p>
<ol type="1">
<li>Each list of children is in decreasing order of rank; and</li>
<li>The elements are stored in heap order.</li>
</ol>
<p>A binomial heap is a forest of heap-ordered binomial trees, where no two trees in the forest have the same rank. Thus, the trees in a binomial heap of size n correspond to the 1s in the binomial representation of n. For example, a binomial heap of size 21 would have one tree of rank 4 (size <span class="math inline">\(2^4 = 16\)</span>), one of rank 2 (size <span class="math inline">\(2^2=4\)</span>), and one of rank 0 (size <span class="math inline">\(2^0=1\)</span>), corresponding to 21’s binomial representation 10101. The binary representation of n contains <span class="math inline">\(\left\lfloor \log (n+1) \right\rfloor\)</span> digits, giving a bound for the number of trees in a binomial heap.</p>
<h2 id="exercise-3.5">Exercise 3.5</h2>
<p>Define <code>findMin</code> directly rather than via a call to <code>removeMinTree</code>.</p>
<h2 id="solution-3.5">Solution 3.5</h2>
<p>See <a href="https://github.com/stappit/okasaki-pfds/blob/ca52a0986bb5baab4bb36266d39235f035378f80/src/Chap03/Exercise05.hs">source</a>.</p>
<h2 id="exercise-3.6">Exercise 3.6</h2>
<p>Given a binomial tree, the rank of the root determines the rank of the children. Reimplement binomial heaps without the redundant rank annotations.</p>
<h2 id="solution-3.6">Solution 3.6</h2>
<p>See <a href="https://github.com/stappit/okasaki-pfds/blob/ca52a0986bb5baab4bb36266d39235f035378f80/src/Chap03/Exercise06.hs">source</a>.</p>
<h2 id="exercise-3.7">Exercise 3.7</h2>
<p>Make a funtor <code>ExplicitMin</code> that creates a heap with a constant time <code>findMin</code> and logarithmic time <code>deleteMin</code>.</p>
<h2 id="solution-3.7">Solution 3.7</h2>
<p>See <a href="https://github.com/stappit/okasaki-pfds/blob/ca52a0986bb5baab4bb36266d39235f035378f80/src/Chap03/Exercise07.hs">source</a>.</p>
<h2 id="red-black-trees">Red-Black Trees</h2>
<p>A red-black tree is a type of balanced binary search tree. The balance is achieved by painting the nodes either red or black whilst maintaining the following two invariants:</p>
<dl>
<dt>Red invariant</dt>
<dd>No red node has a red child
</dd>
<dt>Black invariant</dt>
<dd>Every path from the root node to an empty node contains the same number of black nodes.
</dd>
</dl>
<p>By convention, the empty node is defined to be black.</p>
<figure>
<img src="../../images/red-black-1-node.pdf.png" alt="The red-black tree of size 1" /><figcaption>The red-black tree of size 1</figcaption>
</figure>
<figure>
<img src="../../images/red-black-2-nodes.pdf.png" alt="The red-black tree of size 2" /><figcaption>The red-black tree of size 2</figcaption>
</figure>
<figure>
<img src="../../images/red-black-3-nodes.pdf.png" alt="The red-black tree of size 3" /><figcaption>The red-black tree of size 3</figcaption>
</figure>
<figure>
<img src="../../images/red-black-nontrivial.pdf.png" alt="A non-trivial red-black tree" /><figcaption>A non-trivial red-black tree</figcaption>
</figure>
<p>Our data type is based on a BST with an extra colour field.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Colour</span> <span class="fu">=</span> <span class="dt">R</span>
            <span class="fu">|</span> <span class="dt">B</span>
            <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="kw">data</span> <span class="dt">RBTree</span> a <span class="fu">=</span> <span class="dt">E</span>
              <span class="fu">|</span> <span class="dt">T</span> <span class="dt">Colour</span> (<span class="dt">RBTree</span> a) a (<span class="dt">RBTree</span> a)
              <span class="kw">deriving</span> (<span class="dt">Eq</span>)</code></pre></div>
<h2 id="exercise-3.8">Exercise 3.8</h2>
<p>Prove that the the maximum depth of a node in a red-black tree of size n is at most <span class="math inline">\(2\left\lfloor \log (n+1) \right\rfloor\)</span>.</p>
<h2 id="solution-3.8">Solution 3.8</h2>
<p>We prove this by induction on the number of nodes.</p>
<p>The statement is true for empty trees.</p>
<p>Let <span class="math inline">\(T\)</span> be a red-black tree of depth <span class="math inline">\(d\)</span> with <span class="math inline">\(n\)</span> nodes. Suppose the trees rooted at its children have depths <span class="math inline">\(d_0\)</span> and <span class="math inline">\(d_1\)</span>, with sizes <span class="math inline">\(n_0 \le n_1\)</span>, respectively. In particular, the children are red-black trees with fewer than <span class="math inline">\(n\)</span> nodes. A consequence of the red-black invariant of <span class="math inline">\(T\)</span> is that <span class="math inline">\(d \le 2(d_0 + 1)\)</span>, since <span class="math inline">\(d\)</span> is the length of the longest path and <span class="math inline">\(d_0\)</span> is at least the length of the shortest path. Applying the induction hypothesis to the children yields</p>
<p class="mathjaxWide"><span class="math display">\[
\begin{align}
  d 
  &amp;\le 
  2(d_0 +1) 
  \\
  &amp;\le 
  2(\log (n_0 + 1) + 1)
  \\
  &amp;= 
  2\log (2n_0 + 2) 
  \\
  &amp;\le 
  2\log (n_0 + n_1 + 2) 
  \\
  &amp;= 
  2\log (n + 1).
\end{align}
\]</span></p>
<p>□</p>
<h2 id="exercise-3.9">Exercise 3.9</h2>
<p>Write a function <code>fromOrdList</code> of type</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromOrdList ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">RedBlackTree</span> a</code></pre></div>
<p>that converts a sorted list with no duplicates into a red-black tree in <span class="math inline">\(\mathcal O (n)\)</span> time.</p>
<h2 id="solution-3.9">Solution 3.9</h2>
<p>See <a href="https://github.com/stappit/okasaki-pfds/blob/5cd2c0ae4641edb65ba88f4c7bf0e0a49a23063a/src/Chap03/Exercise09.hs">source</a>.</p>
<p>We must prove both that this implementation has linear complexity and that the resulting tree is red-black invariant.</p>
<dl>
<dt>Proposition</dt>
<dd>The function <code>fromOrdList</code> has linear complexity.
</dd>
</dl>
<p>The helper <code>go</code> makes at most two recursive calls to a list half the size of the original. More precisely,</p>
<p class="mathjaxWide"><span class="math display">\[
T (2k+1) = 2T (k) + \mathcal O (1)
\]</span></p>
<p>and</p>
<p class="mathjaxWide"><span class="math display">\[
T (2k) = T(k) + T (k-1) + \mathcal O (1).
\]</span></p>
<p>These are solved by <span class="math inline">\(T (n) = \mathcal O (n)\)</span>.</p>
<p>□</p>
<p>For the invariants, note that the shape and colouring of the tree doesn’t depend on the particular elements of the list. With this in mind, we will prove a couple of lemmas.</p>
<dl>
<dt>Lemma</dt>
<dd>The black depth (as measured by the algorithm) of <code>fromOrdList xs</code> is exactly <span class="math inline">\(\left\lfloor \log (n+1) - 1\right\rfloor\)</span>, where <code>xs</code> is a list of length <span class="math inline">\(n\)</span>.
</dd>
</dl>
<p>Proof. We prove this by induction on the length of the list.</p>
<p>For length <span class="math inline">\(0\)</span>, the black depth of the resulting empty tree is <span class="math inline">\(-1 = \log (0 + 1) - 1\)</span>.</p>
<p>By the induction hypothesis, the black depth in the odd length case <span class="math inline">\(n=2k+1\)</span> is <span class="math inline">\(\left\lfloor \log (k+1) \right\rfloor\)</span>. This is equal to</p>
<p class="mathjaxWide"><span class="math display">\[
\begin{align}
  &amp;
  \quad \left\lfloor \log (k+1) \right\rfloor +1 -1 
  \\
  &amp;= 
  \left\lfloor \log (k + 1) + \log 2 \right\rfloor - 1 
  \\
  &amp;=
  \left\lfloor \log (2k + 1 + 1) \right\rfloor - 1 
  \\
  &amp;= 
  \left\lfloor \log (n + 1)\right\rfloor - 1.
\end{align}
\]</span></p>
<p>In the even case <span class="math inline">\(n=2k\)</span>, the black depth is <span class="math inline">\(\left\lfloor \log k \right\rfloor\)</span>, again using the induction hypothesis. This simplifies to</p>
<p class="mathjaxWide"><span class="math display">\[
\begin{align}
  &amp;
  \quad
  \left\lfloor \log k \right\rfloor +1 -1 
  \\
  &amp;= 
  \left\lfloor \log 2k \right\rfloor - 1 
  \\
  &amp;= 
  \left\lfloor \log (2k+1) \right\rfloor -1 
  \\
  &amp;= 
  \left\lfloor \log (n+1) \right\rfloor - 1.
\end{align}
\]</span></p>
<p>The second line follows from the fact that <span class="math inline">\(\left\lfloor \log a \right\rfloor &lt; \left\lfloor \log (a+1) \right\rfloor\)</span> if and only if <span class="math inline">\(a = 2^i - 1\)</span> for some <span class="math inline">\(i \in \mathbb N_{\ge 1}\)</span>.</p>
<p>□</p>
<dl>
<dt>Proposition</dt>
<dd>The tree <code>fromOrdList xs</code> is black invariant for any list <code>xs</code>.
</dd>
</dl>
<p>Proof. When the two recursive calls in <code>go (length) xs</code> produce trees of differing black depth, their black depths may differ by at most one. This follows from the previous lemma. By painting the tree with the larger black depth red, we maintain the invariant that both black depths are equal. Thus, the tree <code>fromOrdList xs</code> is black invariant.</p>
<p>□</p>
<dl>
<dt>Lemma</dt>
<dd>The root of the tree <code>fromOrdList xs</code> has a red left child if and only if the length of <code>xs</code> is <span class="math inline">\(2^i - 2\)</span> for some <span class="math inline">\(i \in \mathbb N_{\ge 2}\)</span>. In any other case, both children are black.
</dd>
</dl>
<p>Proof. Let <span class="math inline">\(n\)</span> be the size of the list <code>xs</code>. The function <code>go (length xs) xs</code> makes two recursive calls to create children of sizes approximately <span class="math inline">\(n/2\)</span>. We paint the root of the left child red when their black depths differ, which can only occur if <span class="math inline">\(n = 2k\)</span> is even. Note that the left child always has the greater size and, by the previous lemma, the greater black depth. In this case the black depth of the left is <span class="math inline">\(\left\lfloor \log (k+1) \right\rfloor - 1\)</span>, and the black depth of the right is <span class="math inline">\(\left\lfloor \log k \right\rfloor - 1\)</span>. These differ precisely when <span class="math inline">\(k = 2^i - 1\)</span> for some <span class="math inline">\(i \in \mathbb N_{\ge 1}\)</span>; that is, when <span class="math inline">\(n = 2 (2^i - 1) = 2^{i+1} - 2\)</span>.</p>
<p>□</p>
<dl>
<dt>Proposition</dt>
<dd>The tree <code>fromOrdList xs</code> is red invariant for any list <code>xs</code>.
</dd>
</dl>
<p>Proof. From the previous lemma, <code>fromOrdList xs</code> has a red left child, then then length of <code>xs</code> is <span class="math inline">\(n = 2^{i+1} - 2\)</span>. But then the size of the left child is <span class="math inline">\(n/2 = 2^i - 1\)</span>, so the left child has no red children. Therefore, no red invariant violation is introduced.</p>
<p>□</p>
<h2 id="exercise-3.10">Exercise 3.10</h2>
<p>Reduce redundancy in the <code>balance</code> function as follows:</p>
<ol type="1">
<li>Split <code>balance</code> into two functions, <code>lbalance</code> and <code>rbalance</code>, that test for colour violations in the left and right child, respectively.</li>
<li>Rewrite <code>ins</code> so that it never tests the colour of nodes not on the search path.</li>
</ol>
<h2 id="solution-3.10">Solution 3.10</h2>
<p>See <a href="https://github.com/stappit/okasaki-pfds/blob/ca52a0986bb5baab4bb36266d39235f035378f80/src/Chap03/Exercise10.hs">source</a> for both parts.</p>

<div id="disqus_thread"></div>
<script>
/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
 */
/*
   var disqus_config = function () {
   this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
   this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
   };
 */
(function() {  // DON'T EDIT BELOW THIS LINE
 var d = document, s = d.createElement('script');

 s.src = '//stappit-github-io.disqus.com/embed.js';

 s.setAttribute('data-timestamp', +new Date());
 (d.head || d.body).appendChild(s);
 })();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<script id="dsq-count-scr" src="//stappit-github-io.disqus.com/count.js" async></script>

    </div>

    <footer class="blog-footer">
	    <div class="social">
		    <a href="https://github.com/stappit"><i class="fa fa-github"></i></a>
		    <a href="../../atom.xml"><i class="fa fa-rss"></i></a>
	    </div>

	    </br>

	    Site proudly generated by
	    <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script type="text/javascript" src="../../js/bootstrap.min.js"></script>
    <!--<script type="text/x-mathjax-config">-->
      <!--MathJax.Hub.Config({-->
        <!--"HTML-CSS": { linebreaks: { automatic: true } }-->
      <!--});-->
    <!--</script>-->
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </body>
</html>
